<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RoboDock</title>
    <description>動力船塢工作日誌</description>
    <link>http://www.robodock.net/</link>
    <atom:link href="http://www.robodock.net/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 14 May 2016 18:07:40 +0800</pubDate>
    <lastBuildDate>Sat, 14 May 2016 18:07:40 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>使用 BeagleBone Black 打造 Tor Bridge Relay</title>
        <description>&lt;p&gt;##使用 BeagleBone Black 打造 Tor Bridge Relay&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安裝標準 Debian 系統 Image，因為要作為網路服務器使用，只要安裝 Console 版本即可。
 我這裡裝的是可安裝至 onboard 2GB eMMC 中的 debian wheezy。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; BBB-eMMC-flasher-debian-7.8-console-armhf-2015-07-28-2gb.img
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安裝 Tor package&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; apt-get update; apt-get install tor
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安裝 python 環境&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; apt-get install python2.7 python-pip python-dev build-essential
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安裝 obfsproxy&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; pip install obfsproxy
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;編輯 /etc/tor/torrc&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; SocksPort 0
 ORPort auto
 BridgeRelay 1
 Exitpolicy reject *:*

 ## CHANGEME_1 -&amp;gt; provide a nickname for your bridge, can be anything you like
 #Nickname CHANGEME_1
 ## CHANGEME_2 -&amp;gt; provide some email address so we can contact you if there&#39;s a problem
 #ContactInfo CHANGEME_2

 ServerTransportPlugin obfs3 exec /usr/local/bin/obfsproxy managed
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修正系統時間&lt;/p&gt;

    &lt;p&gt;若系統中沒有 ntpdate ，請先安裝&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; apt-get install ntpdate 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;校時&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ntpdate -b -s -u pool.ntp.org
 hwclock -w
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;我這邊是將校時的動作，寫至 &lt;code class=&quot;highlighter-rouge&quot;&gt;rc.local&lt;/code&gt; 中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;啟動 tor&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; service tor restart
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;檢查 /var/log/tor/log 中是否有相關紀錄&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;開啟防火牆連接埠轉送&lt;/p&gt;

    &lt;p&gt;ORPort 與 obfsproxy 兩個連接埠都須開啟允許外部連接轉送至 BeagleBone 上。&lt;/p&gt;

    &lt;p&gt;obfsproxy 使用埠號可至 /var/log/tor/log 中查詢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可安裝 arm 套件觀看 Tor 系統使用狀況&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; apt-get install tor-arm
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;若需 HTTP 代理伺服器服務可安裝 polipo&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install polipo	
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 14 May 2016 18:07:33 +0800</pubDate>
        <link>http://www.robodock.net/2016/05/14/beaglebonetor-relay.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/05/14/beaglebonetor-relay.html</guid>
        
        
      </item>
    
      <item>
        <title>建立 Chroot 環境</title>
        <description>&lt;h2 id=&quot;chroot&quot;&gt;Chroot&lt;/h2&gt;
&lt;p&gt;暫時將系統根目錄指到特定的目錄下，建立ㄧ個獨立的環境供測試、開發用。在此環境下執行的程式無法看到系統中的其他部分。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;建立工具&lt;/h3&gt;
&lt;p&gt;在 chroot 建立的環境中，需要基本的系統程式才能運作。手動建立環境程序太繁雜，還好有 &lt;code class=&quot;highlighter-rouge&quot;&gt;dchroot&lt;/code&gt; 與 &lt;code class=&quot;highlighter-rouge&quot;&gt;debootstrap&lt;/code&gt; 工具程式幫我們處理。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dchroot&lt;/code&gt; 用來管理不同的 chroot 環境，&lt;code class=&quot;highlighter-rouge&quot;&gt;debootstrap&lt;/code&gt; 則用來在指定目錄中建立一個基本作業系統。附帶一提的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dchroot&lt;/code&gt; 已被 &lt;code class=&quot;highlighter-rouge&quot;&gt;schroot&lt;/code&gt; 取代，雖然仍可用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dchroot&lt;/code&gt; 指令存取，事實上會連結至 &lt;code class=&quot;highlighter-rouge&quot;&gt;schroot&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo apt-get update
$sudo apt-get install dchroot debootstrap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;編輯 &lt;code class=&quot;highlighter-rouge&quot;&gt;dchroot&lt;/code&gt; 設定組態檔&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo vi /etc/schroot/schroot.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;底下是個範例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[saucy]
description=Ubuntu Saucy
location=/test
priority=3
users=demouser
groups=sbuild
root-groups=root
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在指令目錄中安裝系統&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo debootstrap --variant=buildd --arch amd64 saucy /test/ http://mirror.cc.columbia.edu/pub/linux/ubuntu/archive/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--variant＝&lt;/code&gt; 項目表示使用何種類型的環境，&lt;code class=&quot;highlighter-rouge&quot;&gt;buildd&lt;/code&gt; 表示直接安裝成程式開發工具，也就是會安裝 &lt;code class=&quot;highlighter-rouge&quot;&gt;build-essential&lt;/code&gt; 套件。&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--arch&lt;/code&gt; 指定系統架構&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;saucy&lt;/code&gt; 則對應於 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/schroot/schroot.conf&lt;/code&gt; 中的設定&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/test/&lt;/code&gt; 安裝目錄，後方之網址則為來源路徑&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安裝完成後，如果查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;/test/&lt;/code&gt; 目錄內容，可看到如同系統根目錄般的目錄結構：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bin   dev  home  lib64  mnt  proc  run   srv  tmp  var boot  etc  lib   media  opt  root  sbin  sys  usr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最後，進行主系統的 fstab 檔設定，好讓主系統能認得子系統的系統程序檔：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo vi /etc/fstab	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proc /test/proc proc defaults 0 0
sysfs /test/sys sysfs defaults 0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;掛載進子系統&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo mount proc /test/proc -t proc
$sudo mount sysfs /test/sys -t sysfs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;子系統若需要存取與主系統相同的網路環境，可將主系統的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; 檔案複製進子系統&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cp /etc/hosts /test/etc/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;完成&lt;/h3&gt;

&lt;p&gt;chroot 到子系統：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo chroot /test/ /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 14 May 2016 18:01:18 +0800</pubDate>
        <link>http://www.robodock.net/2016/05/14/chroot.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/05/14/chroot.html</guid>
        
        
      </item>
    
      <item>
        <title>BeagleBone Black 的 Device Tree overlays</title>
        <description>&lt;p&gt;Device Tree (DT)是一種用來描述系統中硬體設備的方法，例如描述 UART 如何與系統介接，接腳定義，啟用與否，使用何種驅動程式等等。&lt;/p&gt;

&lt;p&gt;過去數年，各式各樣硬體架構的 Linux 設備蓬勃快速發展，特別是 ARM 架構系統，然而百家爭鳴的場面，加上 ARM 社群無人出面整合，各方的開發者經常隨意的修改並要求 Kernel pull request，讓老大 Torvalds 還因此&lt;a href=&quot;http://article.gmane.org/gmane.linux.ports.arm.omap/55060&quot;&gt;動怒&lt;/a&gt;，因此 BeagleBone 開發人員便實作了 Device Tree 方法，來處理這些硬體設備。&lt;/p&gt;

&lt;p&gt;BeagleBone Black 從 Linux Kernel 3.8 後開始使用 Device Tree，底下來實際看看一個 BB-UART1 DT 檔案內容，如何設定使用 BBB 的 P9_24 與 P9_26 來作為 UART 接腳。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/dts-v1/;
/plugin/;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;DT overlay 檔案中的前兩行說明此 dts 檔案的版本，並說明這是一個 plugin。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/ {
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下來的大括號描述此 DT 的根節點(root node)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;compatible = &quot;ti,beaglebone&quot;, &quot;ti,beaglebone-black&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;“compatible” 說明此 DT 設計用來在何種硬體平台使用，從最相容到最少相容依序排列。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* identification */
part-number = &quot;BB-UART1&quot;;
version = &quot;00A0&quot;; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;part-number 與 version 進一步確保載入適當的 DT overlays。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* state the resources this cape uses */
    exclusive-use =
            /* the pin header uses */
            &quot;P9.24&quot;,        /* uart1_txd */
            &quot;P9.26&quot;,        /* uart1_rxd */
            /* the hardware ip uses */
            &quot;uart1&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;exclusive-use 描述需要的資源，防止其他 overlays 使用這些資源，例如這裏指定的 UART1 TX 與 RX 分別使用 P9.24 與 P9.26 針腳。&lt;/p&gt;

&lt;p&gt;接下來是 device tree 片段，描述要 overlay 哪個 target，例如底下指定的 am33x_pinmux，相容於 pinctrl-single driver(?)&lt;/p&gt;

&lt;p&gt;__overlay__ 節點中的第一項屬性為 bb_uart1_pins，包含針腳的定義，以便供 pinctrl-single driver 使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fragment@0 {
            target = &amp;lt;&amp;amp;am33xx_pinmux&amp;gt;;
            __overlay__ {
                    bb_uart1_pins: pinmux_bb_uart1_pins {
                            pinctrl-single,pins = &amp;lt;
                                    0x184 0x20 /* P9.24 uart1_txd.uart1_txd MODE0 OUTPUT (TX)  */
                                    0x180 0x20 /* P9.26 uart1_rxd.uart1_rxd MODE0 INPUT (RX)  */
                            &amp;gt;;
                    };
            };
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最後一段用來啟動 uart 設備，指定 uart2 與相對應的 pin (bb_uart1_pins)。&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/firmware&lt;/code&gt; 目錄中可以查看許多的 DT overlays 檔案，dts 為原始檔，dtbo則為已編譯檔。而目前系統中已透過 bone cape manager 啟用中的 overlays 則位於 &lt;code class=&quot;highlighter-rouge&quot;&gt;/sys/devices/bone_capemgr.*&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@beaglebone:/lib/firmware# cd /sys/devices/bone_capemgr.*
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;會用 * 的原因為，有時會因啟動順序而改變。接著查看其中的 slots 檔案：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@beaglebone:/sys/devices/bone_capemgr.8# cat slots
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;會出現如下的內容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0: 54:PF--- 
1: 55:PF--- 
2: 56:PF--- 
3: 57:PF--- 
4: ff:P-O-L Bone-LT-eMMC-2G,00A0,Texas Instrument,BB-BONE-EMMC-2G
5: ff:P-O-L Bone-Black-HDMI,00A0,Texas Instrument,BB-BONELT-HDMI
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前三個 slots 是由 capes 的 EEPROM IDs 指定，接下來兩個是開機時載入，第 4 項為板子內建的 EMMC 記憶體，第 5 項用來啟用 HDMI component。&lt;/p&gt;

&lt;p&gt;接著來嘗試載入 UART1 overlay，剛剛在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/firmware&lt;/code&gt; 目錄中可查得 uart1 的 overlay dtbo 檔名為 &lt;code class=&quot;highlighter-rouge&quot;&gt;BB-UART1.dtbo&lt;/code&gt;，因此我們可以如此做：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@beaglebone:/sys/devices/bone_capemgr.8# echo BB-UART1 &amp;gt; slots
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此動作會使用 overlay 來啟用 UART1 設備與驅動程式，確認一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@beaglebone:/sys/devices/bone_capemgr.8# cat slots

0: 54:PF--- 
1: 55:PF--- 
2: 56:PF--- 
3: 57:PF--- 
4: ff:P-O-L Bone-LT-eMMC-2G,00A0,Texas Instrument,BB-BONE-EMMC-2G
5: ff:P-O-L Bone-Black-HDMI,00A0,Texas Instrument,BB-BONELT-HDMI
6: ff:P-O-L Override Board Name,00A0,Override Manuf,BB-UART1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要手動卸載時，在項目號碼前加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 號，echo 進 slots 檔案中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@beaglebone:/sys/devices/bone_capemgr.8# echo -6 &amp;gt; slots
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述手動載入的 overlay 會在重開機即消失，要在開機時自動載入，必須修改 /boot/uEnv.txt 檔案，加入此行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;capemgr.enable_partno=BB-UART1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##編譯新的 Device Tree&lt;/p&gt;

&lt;p&gt;有時需要加入原始系統中沒有的 DT overlays，需要自己將 dts 檔編譯成 dtbo 檔，例如底下 Adafruit 的 SPI bus overlay，方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtc -O dtb -o ADAFRUIT-SPI0-00A0.dtbo -b 0 -@ ADAFRUIT-SPI0-00A0.dts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;系統中如果沒有 dtc 編譯器，可至此處下載：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -c https://raw.githubusercontent.com/RobertCNelson/tools/master/pkgs/dtc.sh
chmod +x dtc.sh
./dtc.sh 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 14 May 2016 17:55:30 +0800</pubDate>
        <link>http://www.robodock.net/2016/05/14/beaglebone-black-device-tree.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/05/14/beaglebone-black-device-tree.html</guid>
        
        
      </item>
    
      <item>
        <title>sudo or root?</title>
        <description>&lt;p&gt;取得 Root 特權的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直接登入 root 帳號&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;遠端使用 ssh 登入 root 帳號&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ssh root@IP_address
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;遠端主機需執行 sshd ，同時允許 root 可透過 ssh 登入， 確定遠端主機中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ssh/sshd.config&lt;/code&gt; 設定檔中有下列一行設定：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PermitRootLogin Yes
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 su 取得 root 特權(成為 root)，系統會要求輸入 &lt;strong&gt;root&lt;/strong&gt; 密碼&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $su
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 sudo 以 root 特權執行程式，不一樣的是系統要求輸入的是 &lt;strong&gt;使用者&lt;/strong&gt; 的密碼&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $sudo command
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;為何一般使用者透過 sudo 指令與自己的密碼，就可取得 root 特權執行程式，其實是透過 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers&lt;/code&gt; 檔案來進行控管。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers&lt;/code&gt;檔案內的設定可決定誰具有取得 root 特權的能力，因此檔案屬性預設為無法編輯，且只有 root 才能檢視，&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers&lt;/code&gt;檔案屬性如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  -r--r----- 1 root root 800 Aug 19  2014 sudoers	   要修改 `/etc/sudoers` 檔內容時，必須使用 **`visudo`** 指令來編輯 `/etc/sudoers` 檔，`visudo` 會啟動系統預設的文字編輯器如 `vi` 或 `nano` ，存檔時會自動檢查輸入內容是否符合 `/etc/sudoers` 語法，確保內容無誤。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在 ubuntu 中可看到如下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/sudoers&lt;/code&gt; 檔內容：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Defaults        env_reset
  Defaults        mail_badpass
  Defaults        secure_path=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;
	
  # User privilege specification
  root    ALL=(ALL:ALL) ALL

  # Members of the admin group may gain root privileges
  %admin ALL=(ALL) ALL

  # Allow members of group sudo to execute any command
  %sudo   ALL=(ALL:ALL) ALL
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;再來看看設定檔內容怎麼寫：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Defaults env_reset
  // 這行用來清除使用者環境變數，避免有害的變數帶入 sudo 環境。
  Defaults secure_path=
  // 這行則定義 sudo 環境下的執行檔搜尋路徑。
	
  root ALL=(ALL:ALL) ALL
  //root 為要套用規則的使用者名稱
  //第一個欄位 ALL 表示要套用到所有“主機”
  //第二個欄位 ALL 表示此使用者可像所有的 users 般執行 commands
  //第三個欄位 ALL 表示此使用者可像所有的 groups 般執行 commands
  //第四個欄位 ALL 表示此使用者可執行所有的 commands
	
  %admin ALL=(ALL) ALL
  使用者名稱前加上 % 則表示群組，在此群組內的使用者將可套用規則。
  依此方法，可對個別使用者進行對不同程式執行權限的詳細控管。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;查詢自己的 sudo 權限內容：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $sudo -l
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 30 Apr 2016 18:16:07 +0800</pubDate>
        <link>http://www.robodock.net/2016/04/30/sudo-or-root.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/04/30/sudo-or-root.html</guid>
        
        
      </item>
    
      <item>
        <title>使用 Raspberry Pi 製作紅外線遙控器</title>
        <description>&lt;p&gt;&lt;em&gt;好消息是，困難的部分總是有人幫你做好了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LIRC&lt;/strong&gt;(Linux Infrared Remote Control)程式庫套件讓我們可以在 Linux 上控制紅外線遙控器，更棒的是現在的 &lt;strong&gt;Raspbian&lt;/strong&gt; OS，也加入了對 LIRC 的支援，只要有些紅外線 LED 電子零件，連接 &lt;strong&gt;Raspberry Pi&lt;/strong&gt; 的 &lt;strong&gt;GPIO&lt;/strong&gt; 針腳，便可輕鬆遙控家裡的電視機或他紅外線遙控設備。&lt;/p&gt;

&lt;p&gt;先來在 Raspberry Pi 上安裝 &lt;strong&gt;LIRC&lt;/strong&gt; 套件:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo apt-get install lirc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在模組引入設定檔 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/modules&lt;/code&gt; 中加入相關設定：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$lirc_dev
$lirc_rpi gpio_in_pin=23 gpio_out_pin=22
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GPIO 腳位可自訂，這裡使用 Pin &lt;strong&gt;22&lt;/strong&gt; 與 Pin &lt;strong&gt;23&lt;/strong&gt;，避開經常定義為 UART 或 I2C 用途的腳位，其中 Pin &lt;strong&gt;22&lt;/strong&gt; 指定用途為輸入訊號(接收紅外線訊號)， Pin &lt;strong&gt;23&lt;/strong&gt; 指定用途為輸出訊號(發射紅外線訊號)。&lt;/p&gt;

&lt;p&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/lirc/hardware.conf&lt;/code&gt; 設定檔:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;########################################################
# /etc/lirc/hardware.conf
#
# Arguments which will be used when launching lircd
LIRCD_ARGS=&quot;--uinput&quot;

# Don&#39;t start lircmd even if there seems to be a good config file
# START_LIRCMD=false

# Don&#39;t start irexec, even if a good config file seems to exist.
# START_IREXEC=false

# Try to load appropriate kernel modules
LOAD_MODULES=true

# Run &quot;lircd --driver=help&quot; for a list of supported drivers.
DRIVER=&quot;default&quot;
# usually /dev/lirc0 is the correct setting for systems using udev
DEVICE=&quot;/dev/lirc0&quot;
MODULES=&quot;lirc_rpi&quot;

# Default configuration files for your hardware if any
LIRCD_CONF=&quot;&quot;
LIRCMD_CONF=&quot;&quot;
########################################################
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;較新版的 Raspbian OS(Debian Jessie) 已經開始改用 Device Tree 來管理硬體設備，使用 Jessie 版本的需要修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/config.txt&lt;/code&gt; 開機啟動組態檔。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtoverlay=lirc-rpi,gpin_in_pin=23,gpio_out_pin=22
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重開機讓設定生效。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;遙控器的紅外線發射與接收是使用不同的元件，紅外線發射通常使用波長為 940nm 的LED，驅動電壓約在 1.2V ~ 2.0V 之間，而接收器通常使用 38KHz 的感應模組。&lt;/p&gt;

&lt;p&gt;紅外線遙控的原理是利用紅外線 LED 發射 PWM(脈波寬度調變) 訊號，而 Raspberry Pi 正好可利用 GPIO 腳位來產生 PWM 訊號，因此接上紅外線 LED 後可用來發射遙控訊號。&lt;/p&gt;

&lt;p&gt;每個遙控器按鍵會有一個對應編碼。必須先知道各個按鍵的編碼後，方可正確遙控設備。&lt;/p&gt;

&lt;p&gt;LIRC 套件中包含了 &lt;code class=&quot;highlighter-rouge&quot;&gt;irrecord&lt;/code&gt; 工具程式，可用來記錄遙控器每個按鍵編碼，所以首先必須先製作一個紅外線接收器，方可記錄遙控器編碼。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;連接紅外線接收器&lt;/h2&gt;

&lt;p&gt;我這邊使用的是 IRM-3638N3 series 的紅外線接收模組，接收頻率 38KHz，工作電壓為 0~6V。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://googledrive.com/host/0B3VMyKy-nGUYdUdGOEQzcVpYRDQ&quot; alt=&quot;IRM3638N3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將接收模組的針腳 1 連接至 RPi GPIO Pin 23(GPIO IN)，針腳 2 連接至 GPIO pin 3(GND)，針腳 3 連接至 GPIO pin 1(+3.3V)，Raspberry Pi 的GPIO 腳位可參考下圖。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.elektronik-kompendium.de/sites/raspberry-pi/fotos/raspberry-pi-15.jpg&quot; alt=&quot;Raspberry GPIO pinout&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著便可測試接收器是否運作正常。先停止 lirc 系統服務，避免設備資源被占用，接著使用 LIRC 提供的工具程式 &lt;code class=&quot;highlighter-rouge&quot;&gt;mode2&lt;/code&gt; 來讀取輸入資料:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo /etc/init.d/lirc stop
mode2 -d /dev/lirc0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一切正常的話，應該可以看到類似底下的輸出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;space 2508
pulse 738
space 1263
pulse 737
space 663
pulse 737
space 1263
pulse 737
space 663
pulse 762
space 1264
pulse 710
space 679
pulse 748
space 611
pulse 788
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;## 錄製遙控器訊號&lt;/p&gt;

&lt;p&gt;接下來便可用 &lt;code class=&quot;highlighter-rouge&quot;&gt;irrecord&lt;/code&gt; 指令來錄製遙控器按鍵編碼：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo /etc/init.d/lirc stop
//停止lirc服務，確定設備資源未被占用

$irrecord -d /dev/lirc0 lircd.conf
//使用 irrecord 指令，將 /dev/lirc0 設備接收到的編碼，錄製到 lircd.conf 檔案中
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;irrecord 是一個互動的程式，只要依照說明指示，一步步進行即可。過程大致如下：&lt;/p&gt;

&lt;p&gt;第一步會先要求你隨意按下遙控器按鍵，按下時畫面會出現點狀 “.” 字符，控制按下的時間長短為出現 10 個 “.” 以內。此步驟會重複兩次，用來找出 PWM 訊號的固定長度。&lt;/p&gt;

&lt;p&gt;第二步，開始記錄按鍵，先輸入按鍵名稱，雖然按鍵名稱並無硬性規定，但基本上還是參考 lirc 的慣用按鍵名稱，例如電源鍵為 KEY_POWER&lt;/p&gt;

&lt;p&gt;第三步會要求對同一個按鍵，快速連續不斷按擊，用來找出延遲設定，避免二次按擊。&lt;/p&gt;

&lt;p&gt;完成後，lircd.conf 的內容看起來像這樣:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin remote

  name  sony
  bits            4
  flags SPACE_ENC|CONST_LENGTH
  eps            30
  aeps          100

  header       2432   587
  one          1211   582
  zero          612   582
  post_data_bits  8
  post_data      0x90
  gap          45003
  min_repeat      2
#  suppress_repeat 2
#  uncomment to suppress unwanted repeats
  toggle_bit_mask 0x0

      begin codes
          KEY_POWER                0xA
          KEY_MUTE                 0x2
      end codes

end remote
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY_POWER&lt;/code&gt; 的 code 為 0xA，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY_MUTE&lt;/code&gt; 為 0x2。&lt;/p&gt;

&lt;p&gt;完成後可將錄製好的 lircd.conf 複製為 /etc/lirc/lircd.conf，可供全域性使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo cp lircd.conf /etc/lirc/lircd.conf
$sudo /etc/init.d/lirc start //啟動 lirc 服務
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;led&quot;&gt;連接紅外線發射 LED&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://googledrive.com/host/0B3VMyKy-nGUYUk4xZkFKUDlFU1E&quot; alt=&quot;紅外線LED&quot; /&gt;&lt;/p&gt;

&lt;p&gt;網路上建議的 LED 接法像這樣，利用一個放大電晶體來驅動紅外線 LED，可讓遙控距離增加到數公尺的距離，如果只是要近距離測試，直接將 LED 接在 GPIO 上也是可以的。&lt;/p&gt;

&lt;p&gt;直接連接的話，將 LED 較長的針腳(+)接至 Rraspberry Pi GPIO Pin 22(GPIO IN)，較短的針腳(-)連接至 GPIO Pin 14(GND)。&lt;/p&gt;

&lt;p&gt;我這邊接起來的測試環境像這樣：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://googledrive.com/host/0B3VMyKy-nGUYaEdTZnpoMzZZeG8&quot; alt=&quot;Raspberry Pi2 GPIO Infrared LED test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;發送遙控訊號時：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$irsend LIST sony &quot;&quot;
//可列出 lircd.conf 中名為 sony 的組態中所有的對應按鍵名稱

$irsend SEND_ONCE sony KEY_POWER
//發送一次 KEY_POWER 遙控碼
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;完成!&lt;/h3&gt;

&lt;p&gt;記得不要惡搞鄰居家的電視機…&lt;/p&gt;
</description>
        <pubDate>Thu, 28 Apr 2016 17:17:23 +0800</pubDate>
        <link>http://www.robodock.net/2016/04/28/raspberry-pi-gpio-infrared-remote-control.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/04/28/raspberry-pi-gpio-infrared-remote-control.html</guid>
        
        
      </item>
    
      <item>
        <title>BeableBone Black 使用 GPIO</title>
        <description>&lt;p&gt;安裝 Adafruit.BBIO python 模組&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install build-essential python-dev python-setuptools python-pip python -smbus

$ sudo pip install Adafruit_BBIO
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;執行下列指令測試模組是否成功安裝：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo python -c &quot;import Adafruit_BBIO.GPIO as GPIO; print GPIO&quot;

#you should see this or similar:
&amp;lt;module &#39;Adafruit_BBIO.GPIO&#39; from &#39;/usr/local/lib/python2.7/dist-packages/Adafruit_BBIO/GPIO.so&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section&quot;&gt;用法:&lt;/h2&gt;

&lt;p&gt;匯入模組:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Adafruit_BBIO.GPIO as GPIO
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;設定 GPIO 為輸入或輸出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GPIO.setup(&quot;P8_12&quot;, GPIO.IN)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;偵測 GPIO 輸入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if GPIO.input(&quot;P8_12&quot;):
   		print(&quot;HIGH&quot;)
else:
   		print(&quot;LOW&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等候 GPIO 事件發生，此方式會一直等候，直到事件發生&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GPIO.wait_for_edge(&quot;P8_12&quot;, GPIO.RISING)
\\GPIO.RISING 從低位變高位
\\GPIO.FALLING 從高位變低位
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一種偵測事件方式，僅在執行時檢查，通常會搭配迴圈進行持續檢測&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#加入偵測事件
GPIO.add_event_detect(&quot;P8_12&quot;, GPIO.FALLING)
#接著可執行其他程式碼
#在想要偵測的地方加入:
if GPIO.event_detected(&quot;P8_12&quot;):
   		print &quot;event detected!&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;beaglebone-black-gpio-&quot;&gt;BeagleBone Black GPIO 腳位參考圖&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://www.mathworks.com/help/supportpkg/beagleboneio/ug/beaglebone_black_pinmap.png&quot; alt=&quot;BeagleBone Black GPIO pin&quot; /&gt;&lt;/p&gt;

&lt;p&gt;連接按鈕元件(push button)，避免按壓按鈕時多次觸發&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Adafruit_BBIO.GPIO as GPIO
import time

GPIO.setup(&quot;P8_12&quot;, GPIO.IN)

while True:
   		if GPIO.input(&quot;P8_12&quot;):
  		print(&#39;button pressed!&#39;)
   	time.sleep(0.1)	//簡單加入延遲迴圈可避免多次觸發
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 17 Apr 2016 12:08:05 +0800</pubDate>
        <link>http://www.robodock.net/2016/04/17/beaglebone-black-gpio.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/04/17/beaglebone-black-gpio.html</guid>
        
        
      </item>
    
      <item>
        <title>vi(vim) Tab 縮排設定</title>
        <description>&lt;p&gt;Python 使用者都知道，程式需要一致的縮排設定方可正常運作，比如說編輯器的&lt;em&gt;tab鍵&lt;/em&gt;設定，如果使用的是 tab 字元，程式從頭到尾的縮排就必須使用 tab 字元，如果是使用空白字元，就必須都使用空白字元，不可混用。&lt;/p&gt;

&lt;p&gt;為了方便統一，我習慣使用 4 個空白字元當作 Python 程式的縮排，底下是使用 vi 編輯器時的設定。&lt;/p&gt;

&lt;p&gt;可設定在 ~/.vimrc 中，做為永久設定：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:set expandtab
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用空白字元 (space) 取代 Tab。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:set tabstop=4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;設定插入 tab 時用 4 個空白 (space) 字元取代。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:set shiftwidth=4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;設定程式縮排為 4 個空白字元 (space)。&lt;/p&gt;

</description>
        <pubDate>Thu, 14 Apr 2016 21:21:47 +0800</pubDate>
        <link>http://www.robodock.net/2016/04/14/vi-tab-stop.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/04/14/vi-tab-stop.html</guid>
        
        
      </item>
    
      <item>
        <title>OS X 下建置 Ruby 開發應用環境</title>
        <description>&lt;h2 id=&quot;os-x--ruby-&quot;&gt;OS X 下建置 Ruby 開發應用環境&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;基本安裝&lt;/h3&gt;
&lt;p&gt;基本安裝適合只想使用單一 Ruby 版本的使用者，開發人員可直接跳過這一段，直接查看 &lt;em&gt;進階安裝&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;OS X 系統中已內建 Ruby 環境，但通常版本老舊，開放原始碼世界變化快速，建議使用最新穩定版。
若環境單純，無多版本需求者，可使用 Homebrew 套件管理工具來安裝：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew install ruby
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;進階安裝&lt;/h3&gt;

&lt;p&gt;開發與應用開放原始碼軟體時，經常會遇到安裝多個程式庫版本的問題，在 Ruby 的世界中，我們可以使用 **版本管理工具 rbenv ** 來達成在不同 Ruby 版本中的作業管理：&lt;/p&gt;

&lt;h3 id=&quot;rbenv&quot;&gt;rbenv&lt;/h3&gt;

&lt;p&gt;rbenv 透過在系統路徑最前方加入 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.rbenv/shims&lt;/code&gt;路徑，透過 shims 程式攔截 ruby 相關指令，再依據所設定的參數，選擇對應的 ruby 版本據以執行。&lt;/p&gt;

&lt;p&gt;rbenv 管理下的不同版本 ruby 系統程式會安裝在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.rbenv/versions/x.x.x&lt;/code&gt; 目錄下。&lt;/p&gt;

&lt;p&gt;使用 Homebrew 安裝 rbenv 版本環境管理工具：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew install rbenv
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更新 rbenv&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew upgrade rbenv ruby-build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一次使用須執行 &lt;code class=&quot;highlighter-rouge&quot;&gt;rbenv init&lt;/code&gt;，依照說明進行初始化設定。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rbenv init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安裝不同版本 Ruby :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rbenv install -l  //列出可安裝版本
$ rbenv install 2.2.3	//安裝 ruby 2.2.3 版
$ rbenv rehash		//在安裝的版本目錄中加入 shims
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要切換使用的 ruby 版本環境：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rbenv version	//查看目前使用版本
$ rbenv local x.x.x	//選擇使用版本
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然後便可正常執行諸如 gem 之類的指令。&lt;/p&gt;

&lt;p&gt;時間一久，系統中可能累積了許多舊版本，移除舊版本可直接清除 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.rbenv/versions&lt;/code&gt; 底下的目錄或透過 &lt;code class=&quot;highlighter-rouge&quot;&gt;rbenv uninstall&lt;/code&gt; 來移除。&lt;/p&gt;

&lt;p&gt;其他參考指令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rbenv versions //查看系統中安裝了哪些版本
$ rbenv version	//查看目前使用版本
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Apr 2016 19:33:41 +0800</pubDate>
        <link>http://www.robodock.net/2016/04/09/osx-ruby-environment.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/04/09/osx-ruby-environment.html</guid>
        
        
      </item>
    
      <item>
        <title>在 BeagleBone Black 或 Raspberry Pi 上使用 RTL-SDR usb dongle</title>
        <description>&lt;h2 id=&quot;beaglebone-black--raspberry-pi--rtl-sdr-usb-dongle&quot;&gt;在 BeagleBone Black 或 Raspberry Pi 上使用 RTL-SDR usb dongle&lt;/h2&gt;

&lt;p&gt;編譯參數如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd rtl-sdr/build
cmake ../ -DINSTALL_UDEV_RULES=ON -DDETACH_KERNEL_DRIVER=ON
make
sudo make install
ldconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重新開機後應可成功驅動，可使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;rtl_test&lt;/code&gt; 命令測試。&lt;/p&gt;

&lt;p&gt;啟動 rtl_tcp server 供其他用戶端程式(如 &lt;code class=&quot;highlighter-rouge&quot;&gt;SDR#&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;GQRX&lt;/code&gt; 連接使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rtl_tcp -a xxx.xxx.xxx.xxx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xxx 為 ip 位址。&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Apr 2016 15:51:52 +0800</pubDate>
        <link>http://www.robodock.net/2016/04/09/rtl-sdr-usb-dongle.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/04/09/rtl-sdr-usb-dongle.html</guid>
        
        
      </item>
    
      <item>
        <title>使用 FFmpeg 將序列圖片轉換成影片</title>
        <description>&lt;h2 id=&quot;ffmpeg-&quot;&gt;使用 FFmpeg 將序列圖片轉換成影片&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -framerate 5 -i img%03d.png -c:v libx264 -r 30 -pix_fmt yuv420p output.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-framerate&lt;/code&gt; 每秒多少張圖片，預設值為 25, &lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt; 影片播放 fps, 省略時使用與輸入framerate 相同數值。&lt;/p&gt;

&lt;p&gt;如果想從一系列的圖片中的特定號碼開始，可使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-start_number&lt;/code&gt; 參數，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -framerate 5 -start_number 126 -i img%03d.png -c:v libx264 -r 30 -pix_fmt yuv420p output.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果影片無法正確顯示時，嘗試使用下列 fps video filter 格式取代 &lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -framerate 5 -i img%03d.png -c:v libx264 -vf fps=25 -pix_fmt yuv420p output.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或指定 format video filter:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -framerate 5 -i img%03d.png -c:v libx264 -vf &quot;fps=25,format=yuv420p&quot; output.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 09 Apr 2016 15:32:16 +0800</pubDate>
        <link>http://www.robodock.net/2016/04/09/use-ffmpeg-create-video-from-series-of-images.html</link>
        <guid isPermaLink="true">http://www.robodock.net/2016/04/09/use-ffmpeg-create-video-from-series-of-images.html</guid>
        
        
      </item>
    
  </channel>
</rss>
